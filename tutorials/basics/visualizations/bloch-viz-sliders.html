<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Bloch Sphere with Sliders</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        overflow: hidden;
        background: white;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #canvas-container {
        flex: 1;
        position: relative;
        min-height: 0;
      }
      canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
      }
      .state {
        position: absolute;
        top: 10px;
        left: 20px;
        font-size: 16px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px 16px;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 10;
      }
      .controls-panel {
        background: #ffffff;
        border-top: 2px solid #e0e0e0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
      }
      .slider-group {
        display: flex;
        align-items: center;
        gap: 15px;
        width: 100%;
        max-width: 600px;
      }
      .slider-label {
        font-weight: 600;
        color: #2d5016;
        font-size: 15px;
        min-width: 90px;
      }
      .slider-group input[type="range"] {
        flex: 1;
        min-width: 200px;
        height: 8px;
        border-radius: 4px;
        background: linear-gradient(to right, #e8f5e0 0%, #2d5016 100%);
        outline: none;
        -webkit-appearance: none;
        cursor: pointer;
      }
      .slider-group input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: #2d5016;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: transform 0.2s;
      }
      .slider-group input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.1);
      }
      .slider-group input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: #2d5016;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: transform 0.2s;
      }
      .slider-group input[type="range"]::-moz-range-thumb:hover {
        transform: scale(1.1);
      }
      .slider-value {
        display: inline-block;
        min-width: 60px;
        text-align: right;
        font-weight: 700;
        color: #2d5016;
        font-size: 16px;
        background: #e8f5e0;
        padding: 4px 12px;
        border-radius: 4px;
      }
      .reset-btn {
        padding: 10px 32px;
        font-size: 14px;
        font-weight: 600;
        border: 2px solid #2d5016;
        background: white;
        color: #2d5016;
        cursor: pointer;
        border-radius: 6px;
        transition: all 0.2s;
        white-space: nowrap;
        margin-top: 5px;
      }
      .reset-btn:hover {
        background: #2d5016;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }
    </style>
    <script src="../bloch-viz/lib/math.min.js"></script>
    <script src="../js/math_support.js"></script>
    <script src="../js/ports.js"></script>
  </head>
  <body>
    <div id="canvas-container">
      <div class="state">
        <span id="ket0">1</span><span>|</span>0<span>&#x232A;</span><wbr><span id="ket1">+0</span><span>|</span>1<span>&#x232A;</span>
      </div>
    </div>

    <div class="controls-panel">
      <div class="slider-group">
        <span class="slider-label">θ (theta):</span>
        <input type="range" id="theta-slider" min="0" max="180" value="0" step="1">
        <span class="slider-value" id="theta-val">0°</span>
      </div>
      <div class="slider-group">
        <span class="slider-label">φ (phi):</span>
        <input type="range" id="phi-slider" min="0" max="360" value="0" step="1">
        <span class="slider-value" id="phi-val">0°</span>
      </div>
      <button class="reset-btn" id="reset">Reset to |0⟩</button>
    </div>

    <script type="module">
      import * as THREE from '../bloch-viz/lib/three.module.js';
      import { OrbitControls } from '../bloch-viz/lib/OrbitControls.js';

      var group, camera, scene, renderer, doDraw = true;
      var arrow, orbit;

      function requestDraw() { doDraw = true; }

      var qubitState = math.matrix([[1], [0]]);

      var tmpVec = new THREE.Vector3();

      function formatComplex(c, fSign) {
        var re = math.re(c), im = math.im(c);
        var showRe = math.abs(re) >= 0.01;
        var showIm = math.abs(im) >= 0.01;
        var reSign = re >= 0;
        var imSign = im >= 0;
        var reFmt = math.format(math.abs(re), {notation: "fixed", precision: 2});
        var imFmt = math.format(math.abs(im), {notation: "fixed", precision: 2});
        if (reFmt.substring(2, 4) == "00") reFmt = reFmt.substring(0, 1);
        if (imFmt.substring(2, 4) == "00") imFmt = imFmt.substring(0, 1);
        if (showRe && showIm) {
          var reSS = reSign ? "" : "&minus;";
          var imSS = imSign ? "+" : "&minus;";
          return (fSign ? "+(" : "(") + reSS + reFmt + imSS + imFmt + "<i>i</i>)";
        } else if (showIm) {
          var imSS = imSign ? (fSign ? "+" : "") : "&minus;";
          return imSS + imFmt + "<i>i</i>";
        } else {
          var reSS = reSign ? (fSign ? "+" : "") : "&minus;";
          return reSS + reFmt;
        }
      }

      function updateInfo() {
        var [[a], [b]] = qubitState._data;
        document.getElementById("ket0").innerHTML = formatComplex(a, false);
        document.getElementById("ket1").innerHTML = formatComplex(b, true);
      }

      function updateStateFromSliders() {
        var thetaDeg = parseFloat(document.getElementById("theta-slider").value);
        var phiDeg = parseFloat(document.getElementById("phi-slider").value);

        document.getElementById("theta-val").textContent = thetaDeg + "°";
        document.getElementById("phi-val").textContent = phiDeg + "°";

        var thetaRad = (thetaDeg * Math.PI) / 180;
        var phiRad = (phiDeg * Math.PI) / 180;

        // Calculate qubit state from angles
        var a = math.complex(Math.cos(thetaRad / 2), 0);
        var b = math.complex(
          Math.sin(thetaRad / 2) * Math.cos(phiRad),
          Math.sin(thetaRad / 2) * Math.sin(phiRad)
        );

        qubitState = math.matrix([[a], [b]]);
        updateInfo();
        updateArrow();
      }

      function updateArrow() {
        tmpVec.set(...stateToBloch(qubitState));
        arrow.setDirection(tmpVec);
        requestDraw();
      }

      document.getElementById("theta-slider").addEventListener("input", updateStateFromSliders);
      document.getElementById("phi-slider").addEventListener("input", updateStateFromSliders);

      document.getElementById("reset").addEventListener("click", function() {
        document.getElementById("theta-slider").value = 0;
        document.getElementById("phi-slider").value = 0;
        updateStateFromSliders();
      });

      updateInfo();
      init3D();
      animate();

      function init3D() {
        THREE.Object3D.DefaultUp.set(0, 0, 1);

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor(0xffffff, 1);

        var container = document.getElementById('canvas-container');
        container.appendChild( renderer.domElement );

        camera = new THREE.PerspectiveCamera( 40, container.clientWidth / container.clientHeight, 1, 1000 );
        camera.position.set(30, 15, 20);
        scene.add( camera );

        onWindowResize();

        orbit = new OrbitControls( camera, renderer.domElement );
        orbit.minDistance = 20;
        orbit.maxDistance = 80;
        orbit.maxPolarAngle = Math.PI / 2;
        orbit.enablePan = false;
        orbit.autoRotate = true;
        orbit.autoRotateSpeed = 1.0;
        orbit.addEventListener('change', requestDraw);

        scene.add( new THREE.AmbientLight( 0x222222 ) );

        var light = new THREE.PointLight( 0xffffff, 1 );
        light.position.set(50, -50, 100);
        scene.add( light );

        scene.add(new THREE.AxesHelper(12));

        var loader = new THREE.TextureLoader();

        var ket0t = loader.load('../assets/ket 0.png', requestDraw);
        var ket1t = loader.load('../assets/ket 1.png', requestDraw);
        var ket0m = new THREE.SpriteMaterial({ map: ket0t, alphaTest: 0.1, sizeAttenuation: false });
        var ket1m = new THREE.SpriteMaterial({ map: ket1t, alphaTest: 0.1, sizeAttenuation: false });
        var ket0s = new THREE.Sprite(ket0m);
        ket0s.renderOrder = 0;
        ket0s.position.set(0, 0, 10);
        ket0s.center.set(-0.5, -0.5);
        ket0s.scale.multiplyScalar(1/32);
        var ket1s = new THREE.Sprite(ket1m);
        ket1s.renderOrder = 0;
        ket1s.position.set(0, 0, -10);
        ket1s.center.set(0.5, 1.5);
        ket1s.scale.multiplyScalar(1/32);
        scene.add(ket0s);
        scene.add(ket1s);

        group = new THREE.Group();
        scene.add(group);

        var meshMaterial = new THREE.MeshLambertMaterial( {
          color: 0xbbbbbb,
          opacity: 0.5,
          transparent: true
        } );

        var meshGeometry = new THREE.SphereGeometry(10, 64, 64);

        var mesh = new THREE.Mesh( meshGeometry, meshMaterial.clone() );
        mesh.material.side = THREE.FrontSide;
        mesh.renderOrder = 1;
        group.add( mesh );

        var circleGeometry = new THREE.CircleGeometry(10.05, 64);
        circleGeometry.vertices.shift();
        circleGeometry.vertices.push(circleGeometry.vertices[0]);

        var circleZMaterial = new THREE.LineDashedMaterial({
          color: 0x000000,
          linewidth: 1,
          scale: 1,
          dashSize: 0.5,
          gapSize: 0.5,
        });
        var circleZGeometry = circleGeometry.clone();
        var circleZ = new THREE.Line(circleZGeometry, circleZMaterial);
        circleZ.computeLineDistances();
        scene.add(circleZ);

        var circleXMaterial = new THREE.LineBasicMaterial({
          color: 0x999999,
          linewidth: 1,
        });
        var circleXGeometry = circleGeometry.clone();
        circleXGeometry.rotateY(Math.PI/2);
        var circleX = new THREE.Line(circleXGeometry, circleXMaterial);
        circleX.computeLineDistances();
        scene.add(circleX);

        var circleYGeometry = circleGeometry.clone();
        circleYGeometry.rotateX(Math.PI/2);
        var circleY = new THREE.Line(circleYGeometry, circleXMaterial);
        circleY.computeLineDistances();
        scene.add(circleY);

        arrow = new THREE.ArrowHelper(new THREE.Vector3(...stateToBloch(qubitState)), new THREE.Vector3(0, 0, 0), 10, 0x000000, 1, 0.4);
        arrow.line.material.linewidth = 2;
        group.add(arrow);

        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        var container = document.getElementById('canvas-container');
        var width = container.clientWidth;
        var height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        requestDraw();
      }

      function animate() {
        orbit.update();
        tmpVec.set(...stateToBloch(qubitState));
        arrow.setDirection(tmpVec);
        renderer.render( scene, camera );
        requestAnimationFrame( animate );
      }
    </script>
  </body>
</html>
