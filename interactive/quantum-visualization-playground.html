<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        (function () {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-View Quantum State Visualizer - quantumstuff.org</title>
    <link rel="stylesheet" href="../tutorials/basics/css/styles.css">
    <link rel="stylesheet" href="../libraries/q.js/Q/Q.css">
    <link rel="stylesheet" href="../libraries/q.js/Q/Q-Circuit-Editor.css">
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Inline CSS variables for standalone operation */
        :root,
        [data-theme="light"] {
            --bg-primary: #faf8f3;
            --bg-card: #fffdfb;
            --text-primary: #2b281f;
            --text-secondary: #6b5e4f;
            --border-subtle: rgba(212, 197, 169, 0.3);
            --color-green: #16a34a;
        }

        [data-theme="dark"] {
            --bg-primary: #1c1a16;
            --bg-card: #32291d;
            --text-primary: #f5f1e8;
            --text-secondary: #c9b898;
            --border-subtle: rgba(212, 197, 169, 0.15);
            --color-green: #16a34a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Q.js circuit styling */
        .qjs-circuit {
            background: #fff;
            border-radius: 8px;
            padding: 1rem;
            margin: 0 auto;
            width: fit-content;
            max-width: 100%;
        }

        .Q-circuit > p {
            display: none !important;
        }

        /* Ensure proper z-index stacking for wires to be visible */
        .Q-circuit-board-background {
            z-index: 0;
        }

        .Q-circuit-board-foreground {
            z-index: 1;
        }

        /* Fix stacking effect visibility */
        .Q-circuit-palette {
            position: relative;
            isolation: isolate;
        }

        /* Remove scrollbars and center circuit */
        .Q-circuit-board-container {
            overflow: visible !important;
            max-height: none !important;
            display: flex !important;
            justify-content: center !important;
        }

        /* Compact layout for single-screen view */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .playground-wrapper {
            max-width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            overflow: hidden;
            padding: 0.4rem;
        }

        .header {
            text-align: center;
            padding: 0.3rem 0;
            flex-shrink: 0;
        }

        .header h1 {
            color: var(--text-primary);
            font-size: 1.25rem;
            margin: 0;
            font-weight: 600;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin: 0;
        }

        /* Circuit - top left (2 cols × 1 row) */
        .circuit-section {
            grid-column: 1 / 3;
            grid-row: 1;
            background: #fff;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 0.7rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .circuit-section h2 {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin: 0 0 0.4rem;
            text-align: center;
            font-weight: 500;
        }

        /* Grid positioning - all boxes are 2×1 horizontal */
        .circuit-section {
            grid-column: 1 / 3;
            grid-row: 1;
        }

        .viz-top-middle {
            grid-column: 3 / 5;
            grid-row: 1;
        }

        .viz-top-right {
            grid-column: 5 / 7;
            grid-row: 1;
        }

        .bloch-box {
            grid-column: 1 / 3;
            grid-row: 2;
        }

        .viz-bottom-middle {
            grid-column: 3 / 5;
            grid-row: 2;
        }

        .viz-bottom-right {
            grid-column: 5 / 7;
            grid-row: 2;
        }

        /* 6 horizontal × 2 vertical grid */
        .main-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: 1fr 1fr;
            gap: 0.5rem;
            flex: 1;
            min-height: 0;
        }

        .viz-box {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            transition: box-shadow 0.2s;
            overflow: hidden;
        }

        .viz-box:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .viz-box h2 {
            color: var(--text-primary);
            font-size: 0.85rem;
            margin: 0 0 0.2rem;
            font-weight: 600;
        }

        .viz-box p {
            color: var(--text-secondary);
            font-size: 0.68rem;
            margin: 0 0 0.25rem;
            line-height: 1.2;
        }

        canvas {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            border-radius: 6px;
        }

        .state-info {
            margin: 0;
            padding: 0.2rem 0.3rem;
            background: var(--bg-primary);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.58rem;
            line-height: 1.2;
            text-align: center;
            color: var(--text-secondary);
            flex-shrink: 0;
            overflow: visible;
        }

        #bloch-container {
            width: 100%;
            flex: 1;
            min-height: 0;
            background: var(--bg-primary);
            border-radius: 6px;
        }

        /* Navigation bar */
        .nav-bar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-subtle);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-bar a {
            color: var(--text-secondary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .nav-bar a:hover {
            color: var(--color-green);
        }

        .nav-separator {
            color: var(--text-secondary);
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <div class="nav-bar">
        <a href="../index.html">
            <i data-lucide="home" style="width:16px;height:16px;"></i>
            Home
        </a>
        <span class="nav-separator">/</span>
        <a href="../playground.html">
            <i data-lucide="arrow-left" style="width:16px;height:16px;"></i>
            Playground
        </a>
        <span class="nav-separator">/</span>
        <span style="color: var(--text-primary); font-weight: 500; font-size: 0.9rem;">Multi-View State Visualizer</span>
    </div>

    <div class="playground-wrapper">
        <div class="header">
            <h1>Multi-View Quantum State Visualizer</h1>
        </div>

        <div class="main-grid">
            <!-- Circuit Editor - Top Left (2×1) -->
            <div class="circuit-section">
                <h2><i data-lucide="zap" style="width:12px;height:12px;vertical-align:middle;"></i> Circuit Editor</h2>
                <div class="qjs-circuit">
                    <div class='Q-circuit-palette'></div>
                    <div id="test-circuit"></div>
                </div>
            </div>

            <!-- Bar Chart - Top Middle (2×1) -->
            <div class="viz-box viz-top-middle">
                <h2>Amplitude Components</h2>
                <p>Real and imaginary parts of each basis state</p>
                <div style="position: relative; flex: 1; min-height: 0; display: flex;">
                    <canvas id="canvas1"></canvas>
                </div>
                <div class="state-info" id="info1"></div>
            </div>

            <!-- Vector Arrows - Top Right (2×1) -->
            <div class="viz-box viz-top-right">
                <h2>Complex Plane</h2>
                <p>State amplitudes as vectors in the complex plane</p>
                <div style="position: relative; flex: 1; min-height: 0; display: flex;">
                    <canvas id="canvas2"></canvas>
                </div>
                <div class="state-info" id="info2"></div>
            </div>

            <!-- Sinusoidal Waves - Bottom Middle (2×1) -->
            <div class="viz-box viz-bottom-middle">
                <h2>Wave Representation</h2>
                <p>Oscillating waves showing amplitude and phase relationships</p>
                <div style="position: relative; flex: 1; min-height: 0; display: flex;">
                    <canvas id="canvas3"></canvas>
                </div>
                <div class="state-info" id="info3"></div>
            </div>

            <!-- Pulse Envelope - Bottom Right (2×1) -->
            <div class="viz-box viz-bottom-right">
                <h2>Microwave Pulse</h2>
                <p>Physical waveform used to manipulate the qubit</p>
                <div style="position: relative; flex: 1; min-height: 0; display: flex;">
                    <canvas id="canvas5"></canvas>
                </div>
                <div class="state-info" id="info5"></div>
            </div>

            <!-- Bloch Sphere - Bottom Left (2×1) -->
            <div class="viz-box bloch-box">
                <h2>Bloch Sphere</h2>
                <p>Geometric representation of the quantum state</p>
                <div id="bloch-container"></div>
                <div class="state-info" id="info4"></div>
            </div>
        </div> <!-- Close main-grid -->
    </div> <!-- Close playground-wrapper -->

    <!-- Q.js Library -->
    <script src="../libraries/q.js/Q/Q.js"></script>
    <script src="../libraries/q.js/Q/Q-ComplexNumber.js"></script>
    <script src="../libraries/q.js/Q/Q-Matrix.js"></script>
    <script src="../libraries/q.js/Q/Q-Qubit.js"></script>
    <script src="../libraries/q.js/Q/Q-Gate.js"></script>
    <script src="../libraries/q.js/Q/Q-History.js"></script>
    <script src="../libraries/q.js/Q/Q-Circuit.js"></script>
    <script src="../libraries/q.js/Q/Q-Circuit-Editor.js"></script>

    <!-- Bloch Sphere libraries -->
    <script src="../libraries/bloch-viz/lib/math.min.js"></script>
    <script src="../libraries/bloch-viz/math_support.js"></script>
    <script src="../libraries/bloch-viz/ports.js"></script>
    <script type="module">
        import * as THREE from '../libraries/bloch-viz/lib/three.module.js';
        import { OrbitControls } from '../libraries/bloch-viz/lib/OrbitControls.js';
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;

        // Signal that THREE.js is loaded
        window.THREELoaded = true;
        window.dispatchEvent(new Event('threeloaded'));
    </script>

    <!-- Quantum utilities -->
    <script src="../tutorials/basics/js/quantum-utils.js"></script>

    <script>
        // Create gate palette (EXACT copy from lesson4.html)
        Array
        .from( document.querySelectorAll( '.Q-circuit-palette' ))
        .forEach( function( el ){
            Q.Circuit.Editor.createPalette( el )
        })

        // Current quantum state
        let state = {
            amp0: { real: 1, imag: 0 },
            amp1: { real: 0, imag: 0 }
        };

        // Update state from circuit
        function updateStateFromCircuit(circuit) {
            const matrixRows = circuit.matrix && circuit.matrix.rows;
            if (!matrixRows || !matrixRows.length) return;

            const amp0 = matrixRows[0][0];
            const amp1 = matrixRows[1][0];

            state = {
                amp0: { real: amp0.real || 0, imag: amp0.imaginary || 0 },
                amp1: { real: amp1.real || 0, imag: amp1.imaginary || 0 }
            };

            drawAll();
        }

        // Listen for circuit evaluation completion
        window.addEventListener('Q.Circuit.evaluate completed', function(event) {
            const evalCircuit = event.detail.circuit;
            if (evalCircuit.name === 'test-circuit') {
                updateStateFromCircuit(evalCircuit);
            }
        });

        // Listen for GUI changes (when gates are dragged) - triggers evaluation
        window.addEventListener('Q gui altered circuit', function(event) {
            const circuit = event.detail.circuit;
            if (circuit.name === 'test-circuit') {
                circuit.evaluate$();  // This triggers the evaluation
            }
        });

        // Option 1: Bar Chart
        function drawBarChart() {
            const canvas = document.getElementById('canvas1');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;

            ctx.clearRect(0, 0, width, height);

            // Draw bars for each amplitude
            function drawBars(label, real, imag, y) {
                const barHeight = 30;
                const maxWidth = w - 100;

                // Label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(label, 10, y + barHeight / 2 + 5);

                // Real part (green)
                const realWidth = Math.abs(real) * maxWidth;
                ctx.fillStyle = '#10b981';
                ctx.fillRect(60, y, realWidth, barHeight * 0.4);
                ctx.fillStyle = '#000';
                ctx.font = '10px monospace';
                ctx.fillText(real.toFixed(3), 65 + realWidth, y + 12);

                // Imaginary part (orange)
                const imagWidth = Math.abs(imag) * maxWidth;
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(60, y + barHeight * 0.5, imagWidth, barHeight * 0.4);
                ctx.fillStyle = '#000';
                ctx.fillText(imag.toFixed(3) + 'i', 65 + imagWidth, y + 28);
            }

            drawBars('|0⟩', state.amp0.real, state.amp0.imag, 60);
            drawBars('|1⟩', state.amp1.real, state.amp1.imag, 160);

            // Legend
            ctx.fillStyle = '#10b981';
            ctx.fillRect(10, h - 30, 20, 8);
            ctx.fillStyle = '#000';
            ctx.font = '11px Arial';
            ctx.fillText('Real', 35, h - 22);

            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(80, h - 30, 20, 8);
            ctx.fillStyle = '#000';
            ctx.fillText('Imaginary', 105, h - 22);

            updateInfo('info1');
        }

        // Option 2: Vector Arrows
        function drawVectorArrows() {
            const canvas = document.getElementById('canvas2');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;

            ctx.clearRect(0, 0, width, height);

            // Draw complex plane axes and arrow
            function drawArrow(label, real, imag, centerY) {
                const centerX = w / 2;
                const scale = 80; // pixels per unit

                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(20, centerY);
                ctx.lineTo(w - 20, centerY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - 80);
                ctx.lineTo(centerX, centerY + 80);
                ctx.stroke();

                // Axis labels
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Real', w - 15, centerY + 15);
                ctx.save();
                ctx.translate(centerX - 15, centerY);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Imag', 0, 0);
                ctx.restore();

                // State label (use Arial for better ket notation rendering)
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, centerX - 60, centerY - 50);

                // Draw arrow
                const endX = centerX + real * scale;
                const endY = centerY - imag * scale;

                // Arrow line
                ctx.strokeStyle = '#2d5016';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Arrow head
                const angle = Math.atan2(endY - centerY, endX - centerX);
                const headLen = 10;
                ctx.fillStyle = '#2d5016';
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - headLen * Math.cos(angle - Math.PI / 6),
                    endY - headLen * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - headLen * Math.cos(angle + Math.PI / 6),
                    endY - headLen * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();

                // Show magnitude
                const mag = Math.sqrt(real * real + imag * imag);
                ctx.fillStyle = '#000';
                ctx.font = '10px monospace';
                ctx.fillText('|ψ| = ' + mag.toFixed(3), w - 80, centerY);
            }

            drawArrow('|0>', state.amp0.real, state.amp0.imag, h * 0.35);
            drawArrow('|1>', state.amp1.real, state.amp1.imag, h * 0.75);

            updateInfo('info2');
        }

        // Option 3: Sinusoidal Waves
        function drawSinusoidalWaves() {
            const canvas = document.getElementById('canvas3');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;

            ctx.clearRect(0, 0, width, height);

            // Draw wave for amplitude
            function drawWave(label, real, imag, centerY) {
                const mag = Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real);

                // Label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(label, 10, centerY - 40);

                // Baseline
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(w, centerY);
                ctx.stroke();

                // Draw sinusoidal wave
                const amplitude = mag * 40; // scale for display
                const frequency = 2; // 2 cycles across canvas

                ctx.strokeStyle = '#2d5016';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let x = 0; x < w; x++) {
                    const t = (x / w) * frequency * 2 * Math.PI;
                    const y = centerY - amplitude * Math.sin(t + phase);
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Show amplitude and phase
                ctx.fillStyle = '#000';
                ctx.font = '10px monospace';
                ctx.fillText('Mag: ' + mag.toFixed(3), 10, centerY + 45);
                ctx.fillText('Phase: ' + (phase * 180 / Math.PI).toFixed(1) + '°', 100, centerY + 45);
            }

            drawWave('|0⟩', state.amp0.real, state.amp0.imag, h * 0.3);
            drawWave('|1⟩', state.amp1.real, state.amp1.imag, h * 0.7);

            updateInfo('info3');
        }

        // Option 4: Bloch Sphere (3D)
        let blochScene, blochCamera, blochRenderer, blochArrow, blochControls;
        let blochInitialized = false;

        function initBlochSphere() {
            if (blochInitialized) return;

            const container = document.getElementById('bloch-container');
            if (!container || typeof THREE === 'undefined') {
                console.log('Waiting for THREE.js to load...');
                return;
            }

            // Get container dimensions
            const width = container.clientWidth || 400;
            const height = container.clientHeight || 300;

            THREE.Object3D.DefaultUp.set(0, 0, 1);

            blochScene = new THREE.Scene();

            blochRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            blochRenderer.setPixelRatio(window.devicePixelRatio);
            blochRenderer.setClearColor(0x000000, 0); // Transparent background
            blochRenderer.setSize(width, height);
            container.appendChild(blochRenderer.domElement);

            blochCamera = new THREE.PerspectiveCamera(40, container.offsetWidth / container.offsetHeight, 1, 1000);
            blochCamera.position.set(30, 15, 20);
            blochScene.add(blochCamera);

            blochControls = new window.OrbitControls(blochCamera, blochRenderer.domElement);
            blochControls.minDistance = 20;
            blochControls.maxDistance = 80;
            blochControls.maxPolarAngle = Math.PI / 2;
            blochControls.enablePan = false;

            blochScene.add(new THREE.AmbientLight(0x222222));

            const light = new THREE.PointLight(0xffffff, 1);
            light.position.set(50, -50, 100);
            blochScene.add(light);

            blochScene.add(new THREE.AxesHelper(12));

            const group = new THREE.Group();
            blochScene.add(group);

            const meshMaterial = new THREE.MeshLambertMaterial({
                color: 0xbbbbbb,
                opacity: 0.5,
                transparent: true
            });

            const meshGeometry = new THREE.SphereGeometry(10, 64, 64);
            const mesh = new THREE.Mesh(meshGeometry, meshMaterial.clone());
            mesh.material.side = THREE.FrontSide;
            mesh.renderOrder = 1;
            group.add(mesh);

            // Coordinate circles
            const circleGeometry = new THREE.CircleGeometry(10.05, 64);
            circleGeometry.vertices.shift();
            circleGeometry.vertices.push(circleGeometry.vertices[0]);

            const circleZMaterial = new THREE.LineDashedMaterial({
                color: 0x000000,
                linewidth: 1,
                dashSize: 0.5,
                gapSize: 0.5,
            });
            const circleZGeometry = circleGeometry.clone();
            const circleZ = new THREE.Line(circleZGeometry, circleZMaterial);
            circleZ.computeLineDistances();
            blochScene.add(circleZ);

            const circleXMaterial = new THREE.LineBasicMaterial({ color: 0x999999, linewidth: 1 });
            const circleXGeometry = circleGeometry.clone();
            circleXGeometry.rotateY(Math.PI / 2);
            const circleX = new THREE.Line(circleXGeometry, circleXMaterial);
            circleX.computeLineDistances();
            blochScene.add(circleX);

            const circleYGeometry = circleGeometry.clone();
            circleYGeometry.rotateX(Math.PI / 2);
            const circleY = new THREE.Line(circleYGeometry, circleXMaterial);
            circleY.computeLineDistances();
            blochScene.add(circleY);

            // State arrow (initially pointing to |0⟩)
            blochArrow = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, 0),
                10,
                0x000000,
                1,
                0.4
            );
            blochArrow.line.material.linewidth = 2;
            group.add(blochArrow);

            blochInitialized = true;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                blochControls.update();
                blochRenderer.render(blochScene, blochCamera);
            }
            animate();
        }

        function drawBlochSphere() {
            if (!blochInitialized) {
                // console.log('Bloch sphere not initialized yet');
                return;
            }

            if (typeof stateToBloch === 'undefined') {
                console.error('stateToBloch function not found - math_support.js not loaded?');
                return;
            }

            if (typeof math === 'undefined') {
                console.error('math.js not loaded');
                return;
            }

            try {
                // Convert state to Bloch coordinates
                const qubitState = math.matrix([[
                    math.complex(state.amp0.real, state.amp0.imag)
                ], [
                    math.complex(state.amp1.real, state.amp1.imag)
                ]]);

                const blochCoords = stateToBloch(qubitState);
                const direction = new THREE.Vector3(blochCoords[0], blochCoords[1], blochCoords[2]);

                blochArrow.setDirection(direction);

                updateInfo('info4');
            } catch (e) {
                console.error('Error updating Bloch sphere:', e);
            }
        }

        // Option 5: Pulse Envelope
        function drawPulseEnvelope() {
            const canvas = document.getElementById('canvas5');
            if (!canvas) {
                console.error('Pulse envelope canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;

            ctx.clearRect(0, 0, width, height);

            // Calculate pulse amplitude from quantum state
            const mag0 = Math.sqrt(state.amp0.real ** 2 + state.amp0.imag ** 2);
            const mag1 = Math.sqrt(state.amp1.real ** 2 + state.amp1.imag ** 2);
            const pulseAmp = mag1; // Pulse amplitude proportional to |1⟩ population
            const phase = Math.atan2(state.amp1.imag, state.amp1.real);

            // Draw baseline
            const centerY = h / 2;
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(w, centerY);
            ctx.stroke();

            // Pulse parameters
            const pulseDuration = 0.8; // fraction of canvas width
            const pulseCenter = w / 2;
            const pulseWidth = w * pulseDuration / 6; // Gaussian width
            const carrierFreq = 15; // oscillations across pulse
            const maxAmplitude = h * 0.35;

            // Draw Gaussian envelope (dashed red)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();

            for (let x = 0; x < w; x++) {
                const t = (x - pulseCenter) / pulseWidth;
                const envelope = Math.exp(-t * t / 2) * pulseAmp;
                const y = centerY - envelope * maxAmplitude;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw negative envelope
            ctx.beginPath();
            for (let x = 0; x < w; x++) {
                const t = (x - pulseCenter) / pulseWidth;
                const envelope = Math.exp(-t * t / 2) * pulseAmp;
                const y = centerY + envelope * maxAmplitude;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw oscillating carrier wave (solid teal)
            ctx.strokeStyle = '#14b8a6';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();

            for (let x = 0; x < w; x++) {
                const t = (x - pulseCenter) / pulseWidth;
                const envelope = Math.exp(-t * t / 2) * pulseAmp;
                const carrier = Math.sin((x / w) * carrierFreq * 2 * Math.PI + phase);
                const y = centerY - envelope * maxAmplitude * carrier;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#000';
            ctx.font = '11px Arial';
            ctx.fillText('Envelope', 10, 20);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('━ ━ ━', 70, 20);

            ctx.fillStyle = '#000';
            ctx.fillText('Carrier', 10, 35);
            ctx.fillStyle = '#14b8a6';
            ctx.fillText('━━━', 60, 35);

            // Pulse info
            ctx.fillStyle = '#000';
            ctx.font = '10px monospace';
            ctx.fillText('Amplitude: ' + pulseAmp.toFixed(3), 10, h - 25);
            ctx.fillText('Phase: ' + (phase * 180 / Math.PI).toFixed(1) + '°', 10, h - 10);

            updateInfo('info5');
        }

        function updateInfo(id) {
            const info = document.getElementById(id);
            const mag0 = Math.sqrt(state.amp0.real ** 2 + state.amp0.imag ** 2);
            const mag1 = Math.sqrt(state.amp1.real ** 2 + state.amp1.imag ** 2);
            info.innerHTML = `|0>: ${state.amp0.real.toFixed(3)} + ${state.amp0.imag.toFixed(3)}i (|ψ|=${mag0.toFixed(3)})<br>` +
                           `|1>: ${state.amp1.real.toFixed(3)} + ${state.amp1.imag.toFixed(3)}i (|ψ|=${mag1.toFixed(3)})`;
        }

        function drawAll() {
            drawBarChart();
            drawVectorArrows();
            drawSinusoidalWaves();
            drawBlochSphere();
            drawPulseEnvelope();
        }

        // Initialize circuit and visualizations after page loads
        window.addEventListener('DOMContentLoaded', function() {
            // Initialize Q.js circuit (1 qubit, 7 moments for easy testing)
            const circuit = new Q.Circuit(1, 7);
            circuit.name = 'test-circuit';
            const domEl = document.getElementById('test-circuit');
            if (domEl) {
                circuit.sort$();
                circuit.toDom(domEl);
                circuit.evaluate$();
            }

            // Initial draw - delay to ensure canvases are rendered
            setTimeout(function() {
                drawAll();
            }, 500);

            // Initialize Bloch sphere after THREE.js loads
            if (window.THREELoaded) {
                initBlochSphere();
            } else {
                window.addEventListener('threeloaded', function() {
                    initBlochSphere();
                });
            }
        });

        // Initialize lucide icons
        lucide.createIcons();
    </script>
</body>
</html>
